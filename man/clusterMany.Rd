% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clusterMany.R
\docType{methods}
\name{clusterMany}
\alias{clusterMany}
\alias{clusterMany,matrixOrHDF5-method}
\alias{clusterMany,SingleCellExperiment-method}
\alias{clusterMany,ClusterExperiment-method}
\alias{clusterMany,SummarizedExperiment-method}
\alias{clusterMany,data.frame-method}
\title{Create a matrix of clustering across values of parameters}
\usage{
\S4method{clusterMany}{matrixOrHDF5}(x, reduceMethod = "none",
  nReducedDims = NA, transFun = NULL, isCount = FALSE, ...)

\S4method{clusterMany}{SingleCellExperiment}(x, ks = NA, clusterFunction,
  reduceMethod = "none", nFilterDims = defaultNDims(x, reduceMethod,
  type = "filterStats"), nReducedDims = defaultNDims(x, reduceMethod,
  type = "reducedDims"), alphas = 0.1, findBestK = FALSE,
  sequential = FALSE, removeSil = FALSE, subsample = FALSE,
  silCutoff = 0, distFunction = NA, betas = 0.9, minSizes = 1,
  transFun = NULL, isCount = FALSE, verbose = FALSE,
  mainClusterArgs = NULL, subsampleArgs = NULL, seqArgs = NULL,
  whichAssay = 1, mc.cores = 1, mc.set.seed = TRUE, run = TRUE,
  ...)

\S4method{clusterMany}{ClusterExperiment}(x, reduceMethod = "none",
  nFilterDims = defaultNDims(x, reduceMethod, type = "filterStats"),
  nReducedDims = defaultNDims(x, reduceMethod, type = "reducedDims"),
  eraseOld = FALSE, ...)

\S4method{clusterMany}{SummarizedExperiment}(x, ...)

\S4method{clusterMany}{data.frame}(x, ...)
}
\arguments{
\item{x}{the data matrix on which to run the clustering. Can be object of the
following classes: matrix (with genes in rows),
\code{\link[SummarizedExperiment]{SummarizedExperiment}},
\code{\link[SingleCellExperiment]{SingleCellExperiment}}
or \code{ClusterExperiment}.}

\item{reduceMethod}{character A character identifying what type of
dimensionality reduction to perform before clustering. Options are 1)
"none", 2) one of listBuiltInReducedDims() or listBuiltInFitlerStats OR 3)
stored filtering or reducedDim values in the object.}

\item{nReducedDims}{vector of the number of dimensions to use (when
\code{reduceMethod} gives a dimensionality reduction method).}

\item{transFun}{a transformation function to be applied to the data. If the
transformation applied to the data creates an error or NA values, then the
function will throw an error. If object is of class
\code{ClusterExperiment}, the stored transformation will be used and giving
this parameter will result in an error.}

\item{isCount}{if \code{transFun=NULL}, then \code{isCount=TRUE} will
determine the transformation as defined by \code{function(x){log2(x+1)}},
and \code{isCount=FALSE} will give a transformation function
\code{function(x){x}}. Ignored if \code{transFun=NULL}. If object is of
class \code{ClusterExperiment}, the stored transformation will be used and
giving this parameter will result in an error.}

\item{...}{For signature \code{SummarizedExperiment}, arguments to be passed 
on to mclapply(if mc.cores>1). For all the other signatures, arguments to be 
passed to the method for signature \code{SummarizedExperiment}.}

\item{ks}{the range of k values (see details for the meaning of \code{k} for
different choices of other parameters).}

\item{clusterFunction}{function used for the clustering. This must be either 
1) a character vector of built-in clustering techniques, or 2) a
\emph{named} list of \code{\link{ClusterFunction}} objects. Current
functions can be found by typing \code{listBuiltInFunctions()} into the
command-line.}

\item{nFilterDims}{vector of the number of the most variable features to keep
(when "var", "abscv", or "mad" is identified in \code{reduceMethod}).}

\item{alphas}{values of alpha to be tried. Only used for clusterFunctions of
type '01'. Determines tightness required in creating clusters from the
dissimilarity matrix. Takes on values in [0,1]. See documentation of
\code{\link{ClusterFunction}}.}

\item{findBestK}{logical, whether should find best K based on average
silhouette width (only used when clusterFunction of type "K").}

\item{sequential}{logical whether to use the sequential strategy (see details
of \code{\link{seqCluster}}). Can be used in combination with
\code{subsample=TRUE} or \code{FALSE}.}

\item{removeSil}{logical as to whether remove when silhouette < silCutoff
(only used if clusterFunction of type "K")}

\item{subsample}{logical as to whether to subsample via
\code{\link{subsampleClustering}}. If TRUE, clustering in mainClustering
step is done on the co-occurance between clusterings in the subsampled
clustering results.  If FALSE, the mainClustering step will be run directly
on \code{x}/\code{diss}}

\item{silCutoff}{Requirement on minimum silhouette width to be included in
cluster (only for combinations where removeSil=TRUE).}

\item{distFunction}{a vector of character strings that are the names of
distance functions found in the global environment. See the help pages of
\code{\link{clusterSingle}} for details about the required format of
distance functions. Currently, this distance function must be applicable
for all clusterFunction types tried. Therefore, it is not possible in
\code{clusterMany} to intermix type "K" and type "01" algorithms if you
also give distances to evaluate via \code{distFunction} unless all
distances give 0-1 values for the distance (and hence are possible for both
type "01" and "K" algorithms).}

\item{betas}{values of \code{beta} to be tried in sequential steps. Only used
for \code{sequential=TRUE}. Determines the similarity between two clusters
required in order to deem the cluster stable. Takes on values in [0,1]. See
documentation of \code{\link{seqCluster}}.}

\item{minSizes}{the minimimum size required for a cluster (in the
\code{mainClustering} step). Clusters smaller than this are not kept and samples
are left unassigned.}

\item{verbose}{logical. If TRUE it will print informative messages.}

\item{mainClusterArgs}{list of arguments to be passed for the mainClustering
step, see help pages of \code{\link{mainClustering}}.}

\item{subsampleArgs}{list of arguments to be passed to the subsampling step
(if \code{subsample=TRUE}), see help pages of
\code{\link{subsampleClustering}}.}

\item{seqArgs}{list of arguments to be passed to \code{\link{seqCluster}}.}

\item{whichAssay}{numeric or character specifying which assay to use. See
\code{\link[SummarizedExperiment]{assay}} for details.}

\item{mc.cores}{the number of threads, passed to \code{\link{mclapply}}.}

\item{mc.set.seed}{logical (takes place of previous argument \code{random.seed}). 
See details below.}

\item{run}{logical. If FALSE, doesn't run clustering, but just returns matrix
of parameters that will be run, for the purpose of inspection by user (with
rownames equal to the names of the resulting column names of clMat object
that would be returned if \code{run=TRUE}). Even if \code{run=FALSE},
however, the function will create the dimensionality reductions of the data
indicated by the user input.}

\item{eraseOld}{logical. Only relevant if input \code{x} is of class
\code{ClusterExperiment}. If TRUE, will erase existing workflow results
(clusterMany as well as mergeClusters and makeConsensus). If FALSE, existing
workflow results will have "\code{_i}" added to the clusterTypes value,
where \code{i} is one more than the largest such existing workflow
clusterTypes.}
}
\value{
If \code{run=TRUE} and the input is not a list of data matrices, will
  return a \code{ClusterExperiment} object, where the results are stored as
  clusterings with clusterTypes \code{clusterMany}. Depending on
  \code{eraseOld} argument above, this will either delete existing such
  objects, or change the clusterTypes of existing objects. See argument
  \code{eraseOld} above. Arbitrarily the first clustering is set as the
  primaryClusteringIndex.

If \code{run=TRUE} and the input is a list of data sets, a list with
  the following objects: \itemize{ \item{\code{clMat}}{ a matrix with each
  column corresponding to a clustering and each row to a sample.}
  \item{\code{clusterInfo}}{ a list with information regarding clustering
  results (only relevant entries for those clusterings with sequential=TRUE)}
  \item{\code{paramMatrix}}{ a matrix giving the parameters of each
  clustering, where each column is a possible parameter set by the user and
  passed to \code{\link{clusterSingle}} and each row of paramMatrix
  corresponds to a clustering in \code{clMat}} \item{\code{mainClusterArgs}}{
  a list of (possibly modified) arguments to mainClusterArgs}
  \item{\code{seqArgs=seqArgs}}{a list of (possibly modified) arguments to
  seqArgs} \item{\code{subsampleArgs}}{a list of (possibly modified)
  arguments to subsampleArgs} }

If \code{run=FALSE} a list similar to that described above, but
  without the clustering results.
}
\description{
Given a range of parameters, this function will return a matrix with the
clustering of the samples across the range, which can be passed to
\code{plotClusters} for visualization.
}
\details{
Some combinations of these parameters are not feasible. See the
  documentation of \code{\link{clusterSingle}} for important information on
  how these parameter choices interact.

If the input is a \code{ClusterExperiment} object, current
  implementation is that existing \code{orderSamples},\code{coClustering} or
  the many dendrogram slots will be retained.

While the function allows for multiple values of clusterFunction,
  the code does not reuse the same subsampling matrix and try different
  clusterFunctions on it. This is because if sequential=TRUE, different
  subsample clusterFunctions will create different sets of data to subsample
  so it is not possible; if sequential=FALSE, we have not implemented
  functionality for this reuse. Setting the \code{mc.set} value,
  however, should mean that the subsampled matrix is the same for each, but
  there is no gain in computational complexity (i.e. each subsampled
  co-occurence matrix is recalculated for each set of parameters).

The argument \code{ks} is interpreted differently for different
  choices of the other parameters. When/if sequential=TRUE, \code{ks} defines
  the argument \code{k0} of \code{\link{seqCluster}}. Otherwise, \code{ks}
  values are the \code{k} values for \strong{both} the mainClustering and
  subsampling step (i.e. assigned to the \code{subsampleArgs} and
  \code{mainClusterArgs} that are passed to \code{\link{mainClustering}} and
  \code{\link{subsampleClustering}} unless \code{k} is set appropriately in
  \code{subsampleArgs}. The passing of these arguments via
  \code{subsampleArgs} will only have an effect if `subsample=TRUE`.
  Similarly, the passing of \code{mainClusterArgs[["k"]]} will only have an
  effect when the clusterFunction argument includes a clustering algorithm of
  type "K". When/if "findBestK=TRUE", \code{ks} also defines the
  \code{kRange} argument of \code{\link{mainClustering}} unless \code{kRange}
  is specified by the user via the \code{mainClusterArgs}; note this means
  that the default option of setting \code{kRange} that depends on the input
  \code{k} (see \code{\link{mainClustering}}) is not available in
  \code{clusterMany}, only in \code{\link{clusterSingle}}.

\emph{Parallelization} If \code{mc.cores>1} then the different 
  clusterings, as requested by the combination of parameters requested by the
  user, will each be on a different core (i.e. each call to 
  \code{clusterSingle}). It does not parallelize the subsampling for
  clusterings where \code{subsample=TRUE}. How to parallelize the subsampling is
  discussed below.

\emph{Parallelization and setting the seed} The following discussion
  assumes that the user has set the seed in the global environment via the 
  call to \code{set.seed} in order to make the results replicable and 
  describes how this will affect the results for clusterings which involve 
  subsampling (\code{subsample=TRUE}) -- if the user does not set 
  \code{set.seed} before calling \code{clusterMany} this discussion has no 
  impact. The argument \code{mc.set.seed} can control how the seed is set 
  across multiple cores so as to guaranteed reproducible results. It is an 
  argument that is passed directly to \code{mclapply} and takes the place of 
  the previous argument `random.seed` (Users should read the documentation in
  \code{\link[parallel]{mcparallel}} for more details). If 
  \code{mc.set.seed=FALSE}, each run of \code{clusterSingle} on a core will 
  use the seed in the global environment (which the user has set via 
  \code{set.seed}), so that each call to \code{clusterSingle} will have the 
  same initial seed. This can be useful if your clusterings use 
  \code{subsample=TRUE} and try different parameters on the same random 
  subsets of data. This is the behavior of the old \code{random.seed} 
  argument. If \code{mc.set.seed=TRUE} AND the user has set the random number
  generator in the global environment to be "L'Ecuyer-CMRG" (via a call 
  \code{RNGkind("L'Ecuyer-CMRG")}) then each core (i.e. each call to 
  \code{clusterSingle}) will have a different seed, but they will stay fixed 
  across multiple calls of \code{clusterMany} -- i.e. the cores, while each 
  having different seeds, will have the same seeds for each run. This makes 
  the calls to \code{clusterMany} reproducible, but will mean that each run 
  of \code{clusterSingle} will be on different subsets of the data. If the
  global environment does not use "L'Ecuyer-CMRG" for sampling, then
  \code{mc.set.seed=TRUE} has no effect

\emph{Parallelization of subsampling} To parallelize the 
  subsampling, the user should pass the argument \code{mc.cores} to 
  \code{subsampleArgs}. The user should be aware, however, that if the 
  argument \code{mc.cores} is also greater than 1 in the call to 
  \code{clusterMany} this will multiple the number of cores that the
  \code{clusterMany} call is making (i.e. each of the \code{mc.core} calls of
  \code{clusterSingle} that is running in parallel with \code{subsample=TRUE}
  will then spawn \code{mc.core} more cores). Users who parallelize the
  subsampling need to be careful about what the argument to
  \code{mc.set.seed} to use, and may need to also pass \code{mc.set.seed} in
  \code{subsampleArgs} to achieve the desired effect, depending on whether
  they have set the RNG to "L'Ecuyer-CMRG". In particular, if you do NOT have
  \code{RNGkind("L'Ecuyer-CMRG")} and you set \code{mc.set.seed=FALSE} in the
  call to \code{clusterMany}, then it will have the effect described above
  (i.e. have the same set of subsampled data in each clustering) ONLY if you
  \emph{also} send the argument \code{mc.set.seed=FALSE} to
  \code{subsampleArgs}. On the other hand, if you set
  \code{RNGkind("L'Ecuyer-CMRG")}, you will have the behavior described above
  when you set \code{mc.set.seed=TRUE} regardless of what value of 
  \code{mc.set.seed} (if any) you pass to \code{subsampleArgs}.

The given \code{reduceMethod} values must either be \emph{all}
  precalculated filtering/dimensionality reduction stored in the appropriate
  location, or must \emph{all} be character values giving a built-in
  filtering/dimensionality reduction methods to be calculated. If some of the
  filtering/dimensionality methods are already calculated and stored, but not
  all, then they will \emph{all} be recalculated (and if they are not all
  built-in methods, this will give an error). So to save computational time
  with pre-calculated dimensionality reduction, the user must make sure they
  are \emph{all} precalculated. Also, user-defined values (i.e. not built-in
  functions) cannot be mixed with built-in functions unless they have already
  been precalculated (see \code{\link{makeFilterStats}} or
  \code{\link{makeReducedDims}}).
}
\examples{
data(simData)

#Example: clustering using pam with different dimensions of pca and different
#k and whether remove negative silhouette values
#check how many and what runs user choices will imply:
checkParams <- clusterMany(simData,reduceMethod="PCA",
nReducedDims=c(5,10,50), clusterFunction="pam", isCount=FALSE,
ks=2:4,findBestK=c(TRUE,FALSE),removeSil=c(TRUE,FALSE),run=FALSE)
print(head(checkParams$paramMatrix))

#Now actually run it
cl <- clusterMany(simData,reduceMethod="PCA", nReducedDims=c(5,10,50),  isCount=FALSE,
clusterFunction="pam",ks=2:4,findBestK=c(TRUE,FALSE),removeSil=c(TRUE,FALSE))
print(cl)
head(colnames(clusterMatrix(cl)))

#make names shorter for plotting
clNames <- clusterLabels(cl)
clNames <- gsub("TRUE", "T", clNames)
clNames <- gsub("FALSE", "F", clNames)
clNames <- gsub("k=NA,", "", clNames)

par(mar=c(2, 10, 1, 1))
plotClusters(cl, axisLine=-2,clusterLabels=clNames)


\dontrun{
#following code takes around 1+ minutes to run because of the subsampling
#that is redone each time:
 set.seed(48120)
system.time(clusterTrack <- clusterMany(simData, ks=2:15,
alphas=c(0.1,0.2,0.3), findBestK=c(TRUE,FALSE), sequential=c(FALSE),
subsample=c(FALSE), removeSil=c(TRUE), clusterFunction="pam",
mainClusterArgs=list(minSize=5, kRange=2:15), mc.cores=1, mc.set.seed=FALSE))
}

}
\seealso{
\code{\link[parallel]{mcparallel}},
  \code{\link[parallel]{mclapply}}, \code{\link{RNGkind}}
}
